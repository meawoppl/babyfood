import time
from warnings import warn

import numpy as np


def iteratePairs(iterable):
    last = None
    for idx in range(len(iterable) - 1):
        nxt = iterable.next()
        if last is not None:
            yield last, nxt
        last = nxt


class GerberWriter:
    """
    Class for the output of gerber vector graphics files.
    This can be used to create layers of a PCB or similar
    project.  It takes in a filepath, or file-like object.
    It takes care of several tediuous error-prone steps namely:
      1. Most supported gerber graphics primitives. (Aperature Macros coming)
      2. Aperature generation and unification
      3. Layer/polarity settings
      4. Formatting + precision/underflow concerns.
      5. Some machine/legacy specific considerations of format
    """
    def __init__(self, pathOrFlo, fFmt=(4, 6), units="MM", comment=None):
        if hasattr(pathOrFlo, "write"):
            self._f = pathOrFlo
        else:
            self._f = open(pathOrFlo, "w")

        self._polaritySet = False
        self._inPolygonMode = False
        self._aprDict = {}

        self._currentX = 0
        self._currentY = 0

        # Sanity check unit formats, and store
        assert len(fFmt) == 2
        self._fFmt = fFmt

        # Sanity check the header bits
        assert units in ["MM", "IN"], "Units much be IN or MM"
        self._units = units

        # Write the gerber file headers
        if comment is None:
            comment = "Autogenerated by babyfood by MRG on " + time.ctime()
        self.writeComment(comment)

        fmtStr = "X%i%iY%i%i" % (self._fFmt + self._fFmt)
        self._f.write("%FSLA" + fmtStr + "*%\n")
        self._f.write("%MO" + units + "*%\n")

        self._currentAperatureCode = None
        self.setLayerPolarity()

    def _trimFloatToPrecision(self, flt, radix=""):
        fmtStr = "%.0" + str(self._fFmt[1]) + "f"
        formatted = fmtStr % round(float(flt), self._fFmt[1])
        beforeDecimal, afterDecimal = formatted.split(".")

        # Warn about MSB clipping. This should probably raise an exception?
        if len(beforeDecimal) > self._fFmt[0]:
            wStr = "WARNING: position %f is getting truncated to %s.%s (msb)!"
            warn(wStr % (flt, beforeDecimal, afterDecimal))
            beforeDecimal = beforeDecimal[0:self._fFmt[0]]

        return beforeDecimal + radix + afterDecimal

    def _fmtCoord(self, xLoc, yLoc, xLab="X", yLab="Y"):
        xStr = xLab + self._trimFloatToPrecision(xLoc)
        yStr = yLab + self._trimFloatToPrecision(yLoc)
        return xStr + yStr

    def setLayerPolarity(self, polarity="D"):
        '''
        Set the layer polarity.  This can be used to toggle between:
        (D)ark - inking of trace/mask
        (C)lear - Removing where mask previously was.
        '''
        assert polarity in ["D", "C"]
        self._f.write("%LP" + polarity + "*%\n")

    def writeComment(self, comment):
        assert "*" not in comment, "* character not allowed in comments"
        self._f.write("G04 " + comment + "*\n")

    def _checkAperature(self):
        # Aperatures not needed for polygon mode, so punt this check
        if self._inPolygonMode:
            return

        if not self._currentAperatureCode:
            raise RuntimeError("No Aperature defined for current move!")

    def _preGraphicsCheck(self):
        self._forceHeader()
        self._forcePolarity()

    def _writeAperatureToFile(self, aprString):
        # Format the aperature to the next available D-code
        dCodeNumber = 10 + len(self._aprDict)
        newAprCode = "D%i" % dCodeNumber

        # Write it to the file, and add it to the index
        self._f.write("%AD" + newAprCode + aprString + "*%\n")
        self._aprDict[aprString] = newAprCode

        # Check the count, and warn when we pass the large mark
        if len(dCodeNumber) > 999:
            warn("WARNING! Aperature counts above 999 not supported by all machines.")

    def _defineAperature(self, aprString, setAsCurrent):
        # See if we already have this aperature
        # If not, add it to the aperature registry
        if aprString not in self._aprDict:
            self._writeAperatureToFile(aprString)

        # Look up the aperature
        thisAprCode = self._aprDict[aprString]

        # Set it to current if requested
        if setAsCurrent:
            self.setAperature(thisAprCode)

        # Return the code of possible reuse
        return thisAprCode

    def setAperature(self, aprCode):
        assert aprCode in self._aprDict.values(), aprCode + " is not in " + str(self._aprDict)
        self._f.write(aprCode + "*\n")
        self._currentAperatureCode = aprCode

    def finalize(self):
        self._f.write("M02*\n")
        self._f.flush()
        self._f.close()

    def _linearMove(self, endX, endY, dCode):
        '''
        Low level command which encompasses all linear moves,
        This includes light, dark, and flash moves
        '''
        # Make sure an aperature is defined.
        self._checkAperature()

        formattedCoords = self._fmtCoord(endX, endY)
        dCodeStr = "D%02i" % dCode
        # Stroke w/ current aperature
        if dCode == 1:
            cmdString = "G01" + formattedCoords + dCodeStr
        # Light off move and flash
        elif dCode in [2, 3]:
            cmdString = formattedCoords + dCodeStr
        else:
            raise RuntimeError("Unrecognized dCode " + dCodeStr)
        self._f.write(cmdString + "*\n")

        self._currentX = endX
        self._currentY = endY

    def _arcMove(self, endX, endY, cX, cY, direction, dCode=1):
        # Make sure an aperature is defined.
        self._checkAperature()

        # Make estiamates of the radius, and sanity check the coords
        rEst1 = np.sqrt((self._currentX - cX) ** 2 + (self._currentY - cY) ** 2)
        rEst2 = np.sqrt((endX - cX) ** 2 + (endY - cY) ** 2)
        if np.abs(rEst1 - rEst2) > 0.001:
            warn("WARNING: Large deviation in computed radius in arc-move!")

        dCode = "D%02i" % dCode

        if direction == "CW":
            gCode = "G02"
        elif direction == "CCW":
            gCode = "G03"
        else:
            raise RuntimeError("Direction must be CW or CCW!")

        # Compute the offset of the circle center point from the starting coordiante
        xOffset = cX - self._currentX
        yOffset = cY - self._currentY

        # Assemble the command string
        cmdString = gCode
        cmdString += self._fmtCoord(endX, endY)
        cmdString += self._fmtCoord(xOffset, yOffset, xLab="I", yLab="J")
        cmdString += dCode

        # Set to multi-quadrant mode
        self._f.write("G75*\n")

        # Write it
        self._f.write(cmdString + "*\n")

        # Update the internal position tracker
        self._currentX = endX
        self._currentY = endY

    def _startPolygonMode(self):
        self._f.write("G36*\n")
        self._inPolygonMode = True

    def _stopPolygonMode(self, *args):
        # MRG TODO: Check args . . .
        self._f.write("G37*\n")
        self._inPolygonMode = False
