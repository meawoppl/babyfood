import time
from warnings import warn

import numpy as np


def iteratePairs(iterable):
    last = None
    for idx in range(len(iterable) - 1):
        nxt = iterable.next()
        if last is not None:
            yield last, nxt
        last = nxt


# MRG TODO: Integrate below into the class.
def formatFloat(fl, fmt=(4, 4)):
    stringFmt = "%.0" + str(fmt[1]) + "f"
    string = stringFmt % fl
    intPos, decPos = string.split(".")

    if len(intPos) > fmt[0]:
        warn("WARNING: position %f is getting truncated (msb)!")
        intPos = intPos[0:3]

    return intPos + decPos


def fmtCoord(xLoc, yLoc, xFmt=(4, 4), yFmt=(4, 4), xLab="X", yLab="Y"):
    return xLab + formatFloat(xLoc, fmt=xFmt) + yLab + formatFloat(yLoc, fmt=yFmt)


class GerberWriter:
    """
    Class for the output of gerber vector graphics files.
    This can be used to create layers of a PCB or similar
    project.  It takes in a filepath, or file-like object.
    It takes care of several tediuous error-prone steps namely:
      1. Most supported gerber graphics primitives. (Aperature Macros coming)
      2. Aperature generation and unification
      3. Layer/polarity settings
      4. Formatting + precision/underflow concerns.
      5. Some machiene/legacy specific considerations of format
    """
    def __init__(self, pathOrFlo, xFmt=(4, 4), yFmt=(4, 4), units="MM", comment=None):
        if hasattr(pathOrFlo, "write"):
            self._f = pathOrFlo
        else:
            self._f = open(pathOrFlo, "w")

        self._polaritySet = False
        self._inPolygonMode = False

        self._aprDict = {}

        self._currentX = 0
        self._currentY = 0

        # Sanity check unit formats, and store
        assert len(xFmt) == 2
        assert len(yFmt) == 2
        self._xFmt = xFmt
        self._yFmt = yFmt

        # Sanity check the header bits
        assert units in ["MM", "IN"], "Units much be IN or MM"
        self._units = units

        # Write the gerber file headers
        if comment is None:
            comment = "Autogenerated by babyfood by MRG on " + time.ctime()
        self.writeComment(comment)

        fmtStr = "X%i%iY%i%i" % (self._xFmt + self._yFmt)
        self._f.write("%FSLA" + fmtStr + "*%\n")
        self._f.write("%MO" + units + "*%\n")

        self.setLayerPolarity()

    def setLayerPolarity(self, polarity="D"):
        '''
        Set the layer polarity.  This can be used to toggle between:
        (D)ark - inking of trace/mask
        (C)lear - Removing where mask previously was.
        '''
        assert polarity in ["D", "C"]
        self._f.write("%LP" + polarity + "*%\n")

    def writeComment(self, comment):
        assert "*" not in comment, "* character not allowed in comments"
        self._f.write("G04" + comment + "*\n")

    def _checkAperature(self):
        # Aperatures not needed for polygon mode
        if self._inPolygonMode:
            return
        if not self._currentAperatureCode:
            raise RuntimeError("No Aperature defined for current move!")

    def _preGraphicsCheck(self):
        self._forceHeader()
        self._forcePolarity()

    def _defineAperature(self, aprString, setAsCurrent):
        if aprString not in self._aprDict:
            newAprCode = "D%i" % (10 + len(self._aprDict))
            self._f.write("%AD" + newAprCode + aprString + "*%\n")
            self._aprDict[aprString] = newAprCode

        if len(self._aprDict) > 999:
            warn("WARNING! Aperature counts above 999 not supported by all machines.")

        thisAprCode = self._aprDict[aprString]

        if setAsCurrent:
            self.setAperature(thisAprCode)

        return thisAprCode

    def setAperature(self, aprCode):
        assert aprCode in self._aprDict.values(), aprCode + " is not in " + str(self._aprDict)
        self._f.write(aprCode + "*\n")
        self._currentAperatureCode = aprCode

    def finalize(self):
        self._f.write("M02*\n")
        self._f.flush()
        self._f.close()

    def _linearMove(self, endX, endY, dCode):
        '''
        Low level command which encompasses all linear moves,
        This includes light, dark, and flash moves
        '''
        # Make sure an aperature is defined.
        self._checkAperature()

        # unit sanitize
        endX = float(self._uc(endX))
        endY = float(self._uc(endY))

        formattedCoords = fmtCoord(endX, endY, self._xFmt, self._yFmt)
        dCodeStr = "D%02i" % dCode
        # Stroke w/ current aperature
        if dCode == 1:
            cmdString = "G01" + formattedCoords + dCodeStr
        # Light off move and flash
        elif dCode in [2, 3]:
            cmdString = formattedCoords + dCodeStr
        else:
            raise RuntimeError("Unrecognized dCode " + dCodeStr)
        self._f.write(cmdString + "*\n")

        self._currentX = endX
        self._currentY = endY

    def _arcMove(self, endX, endY, cX, cY, direction, dCode=1):
        # Make sure an aperature is defined.
        self._checkAperature()

        # Unit flatten to the file unit types
        endX = float(self._uc(endX))
        endY = float(self._uc(endY))
        cX = float(self._uc(cX))
        cY = float(self._uc(cY))

        # Make estiamates of the radius, and sanity check the coords
        rEst1 = np.sqrt((self._currentX - cX) ** 2 + (self._currentY - cY) ** 2)
        rEst2 = np.sqrt((endX - cX) ** 2 + (endY - cY) ** 2)
        if np.abs(rEst1 - rEst2) > 0.001:
            warn("WARNING: Large deviation in computed radius in arc-move!")

        dCode = "D%02i" % dCode

        if direction == "CW":
            gCode = "G02"
        elif direction == "CCW":
            gCode = "G03"
        else:
            raise RuntimeError("Direction must be CW or CCW!")

        # Compute the offset of the circle center point from the starting coordiante
        xOffset = cX - self._currentX
        yOffset = cY - self._currentY

        # Assemble the command string
        cmdString = gCode
        cmdString += fmtCoord(endX, endY)
        cmdString += fmtCoord(xOffset, yOffset, xLab="I", yLab="J")
        cmdString += dCode

        # Set to multi-quadrant mode
        self._f.write("G75*\n")

        # Write it
        self._f.write(cmdString + "*\n")

        # Update the internal position tracker
        self._currentX = endX
        self._currentY = endY

    def arcLineTo(self, endX, endY, cX, cY, direction):
        self._arcMove(endX, endY, cX, cY, direction)

    def _startPolygonMode(self):
        self._f.write("G36*\n")
        self._inPolygonMode = True

    def _stopPolygonMode(self, *args):
        # MRG TODO: Check args . . .
        self._f.write("G37*\n")
        self._inPolygonMode = False
